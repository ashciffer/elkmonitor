<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script type="text/javascript" src="static/js/jquery.min.js"></script>
    <script type="text/javascript" src="static/js/echarts.js"></script>
    <script type="text/javascript" src="static/js/vintage.js"></script>
    <script type="text/javascript">
        function GetValueFromArray(s, k) {
            de = 0.0;
            for (i in s) {
                if (s[i].key == k) {
                    return s[i].doc_count
                }
            }
            return de
        }
    </script>
    >
    <title>Ash</title>
    <style type="text/css">

        * {
            margin: 0;
            padding: 0;
        }

        .main {
            width: 100%;
            height: 100%;
            position: absolute;

        }

    </style>
</head>
<body>
<div class="main">
    <div id="taobao_sync" style="height: 400px;width: auto"></div>
    <script type="text/javascript">
        var dom = document.getElementById("taobao_sync");
        var ts = echarts.init(dom, 'vintage');
        ts_option = null;
        var ts_key_map = new Map();
        var ts_app = {};
        var ts_key_array = [];
        ts.showLoading({
            text: '正在努力的读取数据中...',
        });
        function load_taobao_sync() {
            $.ajax({
                type: "post",
                async: true, //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行）
                url: "/rpc/realtime", //请求发送到TestServlet处
                data: {"type": "taobao", "sync": true},
                dataType: "json", //类型为数组
                success: function (result) {
                    var ts_se = ts_option.series
                    series_count = ts_se.length
                    if (result) {
                        ts_option.xAxis[0].data.shift();
                        ts_option.xAxis[0].data.push(result.time.split(" ")[1]);
                        //分组
                        ts_d = result.value
                        for (k in ts_d) {
                            if (!ts_key_map.has(ts_d[k].key)) {
                                ts_key_map.set(ts_d[k].key, d[k].key)
                                ts_key_array.push(ts_d[k].key)
                            }
                        }

                        console.log(ts_key_array)
                        for (r in ts_key_array) {
                            find = false;
                            for (var i = 0; i < series_count; i++) {
                                gvfa = GetValueFromArray(ts_d,ts_key_array[r])
                                if (ts_se[i].name == ts_key_array[r]) {
                                    find = true
                                    ts_se[i].data.shift();
                                    ts_se[i].data.push(gvfa);
                                }
                            }

                            //增加一个新的线条
                            if (!find) {
                                newob = {
                                    type: "line",
                                    name: ts_key_array[r],
                                    data: [GetValueFromArray(ts_d,key_array[r])]
                                }
                                ts_se.push(newob)
                            }
                        }
                        ts.setOption(ts_option)
                    }

                },
                error: function (errorMsg) {
                    //请求失败时执行该函数
                    alert("老数据处理失败!");

                }
            })
        }
        ts_app.timeTicket = setInterval(function () {
            load_taobao_sync()
        }, 5000 * 60);
        ;
        $.ajax({
            type: "post",
            async: true, //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行）
            url: "/rpc/historydata", //请求发送到TestServlet处
            data: {"type": "taobao", "sync": true},
            dataType: "json", //类型为数组
            success: function (result) {
                for (i in result) {
                    ts_d = result[i].value
                    for (k in ts_d) {
                        if (!ts_key_map.has(ts_d[k].key)) {
                            ts_key_map.set(ts_d[k].key, ts_d[k].key)
                        }
                    }

                }
                console.log(ts_key_map)
                ts_key_map.forEach(function (item, key) {
                    ts_key_array.push(key)
                })
                ts_option = {
                    title: {
                        text: '淘宝 sync'
                    },
                    legend: {
                        data: ts_key_array
                    },
                    tooltip: {
                        trigger: 'axis'
                    },
                    toolbox: {
                        show: true,
                        feature: {
                            mark: {
                                show: true
                            },
                            dataView: {
                                show: true,
                                readOnly: false
                            },
                            magicType: {
                                show: true,
                                type: ['bar', 'stack', 'tiled']
                            },
                            restore: {
                                show: true
                            },
                            saveAsImage: {
                                show: true
                            }
                        }
                    },
                    calculable: true,
                    xAxis: [
                        {
                            data: (function () {
                                var xaxis_data = [];
                                for (i in result) {
                                    xaxis_data.unshift(result[i].time.split(" ")[1])
                                }
                                return xaxis_data;
                            })()
                        }
                    ],
                    yAxis: {},
                    series: (function () {
                        var res = [];
                        for (i in ts_key_array) {
                            res.push({
                                type: "line",
                                name: ts_key_array[i],
                                data: (function () {
                                    var series_data = [];
                                    for (n in result) {
                                        flag = false;
                                        for (k in result[n].value) {
                                            if (result[n].value[k].key == ts_key_array[i]) {
                                                flag = true
                                                series_data.unshift(result[n].value[k].doc_count)
                                            }
                                        }

                                        if (!flag) {
                                            series_data.unshift(0)
                                        }
                                    }
                                    return series_data;
                                })()
                            })
                        }
                        return res
                    })()
                };
                console.log(ts_option)
                ts.setOption(ts_option);
                ts.hideLoading();

            },
            error: function (errorMsg) {
                //请求失败时执行该函数
                ts.showLoading()

            }
        })
    </script>
    <div id="taobao_async" style="height: 400px;width: auto"></div>
    <script type="text/javascript">
        var dom = document.getElementById("taobao_async");
        var tas = echarts.init(dom, 'vintage');
        option = null;
        var key_map = new Map();
        var app = {};
        var key_array = [];
        tas.showLoading({
            text: '正在努力的读取数据中...',
        });
        function load_taobao_async() {
            $.ajax({
                type: "post",
                async: true, //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行）
                url: "/rpc/realtime", //请求发送到TestServlet处
                data: {"type": "taobao", "sync": false},
                dataType: "json", //类型为数组
                success: function (result) {
                    var se = option.series
                    series_count = se.length
                    if (result) {
                        option.xAxis[0].data.shift();
                        option.xAxis[0].data.push(result.time.split(" ")[1]);
                        //分组
                        d = result.value
                        for (k in d) {
                            if (!key_map.has(d[k].key)) {
                                key_map.set(d[k].key, d[k].key)
                                key_array.push(d[k].key)
                            }
                        }

                        console.log(key_array)
                        for (r in key_array) {
                            find = false;
                            for (var i = 0; i < series_count; i++) {
                                gvfa = GetValueFromArray(d,key_array[r])
                                if (se[i].name == key_array[r]) {
                                    find = true
                                    se[i].data.shift();
                                    se[i].data.push(gvfa);
                                }
                            }

                            //增加一个新的线条
                            if (!find) {
                                newob = {
                                    type: "line",
                                    name: key_array[r],
                                    data: [GetValueFromArray(d,key_array[r])]
                                }
                                se.push(newob)
                            }
                        }
                        tas.setOption(option)
                    }

                },
                error: function (errorMsg) {
                    //请求失败时执行该函数
                    alert("老数据处理失败!");

                }
            })
        }
        app.timeTicket = setInterval(function () {
            load_taobao_async()
        }, 5000 * 60);
        ;
        $.ajax({
            type: "post",
            async: true, //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行）
            url: "/rpc/historydata", //请求发送到TestServlet处
            data: {"type": "taobao", "sync": false},
            dataType: "json", //类型为数组
            success: function (result) {
                for (i in result) {
                    d = result[i].value
                    for (k in d) {
                        if (!key_map.has(d[k].key)) {
                            key_map.set(d[k].key, d[k].key)
                        }
                    }

                }
                key_map.forEach(function (item, key) {
                    key_array.push(key)
                })
                option = {
                    title: {
                        text: '淘宝 async'
                    },
                    legend: {
                        data: key_array
                    },
                    tooltip: {
                        trigger: 'axis'
                    },
                    toolbox: {
                        show: true,
                        feature: {
                            mark: {
                                show: true
                            },
                            dataView: {
                                show: true,
                                readOnly: false
                            },
                            magicType: {
                                show: true,
                                type: ['bar', 'stack', 'tiled']
                            },
                            restore: {
                                show: true
                            },
                            saveAsImage: {
                                show: true
                            }
                        }
                    },
                    calculable: true,
                    xAxis: [
                        {
                            data: (function () {
                                var xaxis_data = [];
                                for (i in result) {
                                    xaxis_data.unshift(result[i].time.split(" ")[1])
                                }
                                return xaxis_data;
                            })()
                        }
                    ],
                    yAxis: {},
                    series: (function () {
                        var res = [];
                        for (i in key_array) {
                            res.push({
                                type: "line",
                                name: key_array[i],
                                data: (function () {
                                    var series_data = [];
                                    for (n in result) {
                                        flag = false;
                                        for (k in result[n].value) {
                                            if (result[n].value[k].key == key_array[i]) {
                                                flag = true
                                                series_data.unshift(result[n].value[k].doc_count)
                                            }
                                        }

                                        if (!flag) {
                                            series_data.unshift(0)
                                        }
                                    }
                                    return series_data;
                                })()
                            })
                        }
                        return res
                    })()
                };
                console.log(option)
                tas.setOption(option);
                tas.hideLoading();

            },
            error: function (errorMsg) {
                //请求失败时执行该函数
                tas.showLoading()

            }
        })
    </script>
    <div id="rpc_sync" style="height: 400px;width: auto"></div>
    <script type="text/javascript">
        var dom = document.getElementById("rpc_sync");
        var rs = echarts.init(dom, 'vintage');
        option = null;
        var key_map = new Map();
        var app = {};
        var key_array = [];
        rs.showLoading({
            text: '正在努力的读取数据中...',
        });
        function load_rpc_sync() {
            $.ajax({
                type: "post",
                async: true, //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行）
                url: "/rpc/realtime", //请求发送到TestServlet处
                data: {"type": "rpc", "sync": true},
                dataType: "json", //类型为数组
                success: function (result) {
                    var se = option.series
                    series_count = se.length
                    if (result) {
                        option.xAxis[0].data.shift();
                        option.xAxis[0].data.push(result.time.split(" ")[1]);
                        //分组
                        d = result.value
                        for (k in d) {
                            if (!key_map.has(d[k].key)) {
                                key_map.set(d[k].key, d[k].key)
                                key_array.push(d[k].key)
                            }
                        }
                        for (r in key_array) {
                            find = false;
                            for (var i = 0; i < series_count; i++) {
                                gvfa = GetValueFromArray(d,key_array[r])
                                if (se[i].name == key_array[r]) {
                                    find = true
                                    se[i].data.shift();
                                    se[i].data.push(gvfa);
                                }
                            }

                            //增加一个新的线条
                            if (!find) {
                                newob = {
                                    type: "line",
                                    name: key_array[r],
                                    data: [GetValueFromArray(d,key_array[r])]
                                }
                                se.push(newob)
                            }
                        }
                        rs.setOption(option)
                    }

                },
                error: function (errorMsg) {
                    //请求失败时执行该函数
                    alert("历史数据处理失败!");

                }
            })
        }
        app.timeTicket = setInterval(function () {
            load_rpc_sync()
        }, 5000 * 60);
        ;
        $.ajax({
            type: "post",
            async: true, //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行）
            url: "/rpc/historydata", //请求发送到TestServlet处
            data: {"type": "rpc", "sync": true},
            dataType: "json", //类型为数组
            success: function (result) {
                for (i in result) {
                    d = result[i].value
                    for (k in d) {
                        if (!key_map.has(d[k].key)) {
                            key_map.set(d[k].key, d[k].key)
                        }
                    }

                }
                key_map.forEach(function (item, key) {
                    key_array.push(key)
                })
                option = {
                    title: {
                        text: '上海 sync'
                    },
                    legend: {
                        data: key_array
                    },
                    tooltip: {
                        trigger: 'axis'
                    },
                    toolbox: {
                        show: true,
                        feature: {
                            mark: {
                                show: true
                            },
                            dataView: {
                                show: true,
                                readOnly: false
                            },
                            magicType: {
                                show: true,
                                type: ['bar', 'stack', 'tiled']
                            },
                            restore: {
                                show: true
                            },
                            saveAsImage: {
                                show: true
                            }
                        }
                    },
                    calculable: true,
                    xAxis: [
                        {
                            data: (function () {
                                var xaxis_data = [];
                                for (i in result) {
                                    xaxis_data.unshift(result[i].time.split(" ")[1])
                                }
                                return xaxis_data;
                            })()
                        }
                    ],
                    yAxis: {},
                    series: (function () {
                        var res = [];
                        for (i in key_array) {
                            res.push({
                                type: "line",
                                name: key_array[i],
                                data: (function () {
                                    var series_data = [];
                                    for (n in result) {
                                        flag = false;
                                        for (k in result[n].value) {
                                            if (result[n].value[k].key == key_array[i]) {
                                                flag = true
                                                series_data.unshift(result[n].value[k].doc_count)
                                            }
                                        }

                                        if (!flag) {
                                            series_data.unshift(0)
                                        }
                                    }
                                    return series_data;
                                })()
                            })
                        }
                        return res
                    })()
                };
                rs.setOption(option);
                rs.hideLoading();

            },
            error: function (errorMsg) {
                //请求失败时执行该函数
                rs.showLoading()

            }
        })
    </script>
    <div id="rpc_async" style="height: 400px;width: auto"></div>
    <script type="text/javascript">
        var dom = document.getElementById("rpc_async");
        var ras = echarts.init(dom, 'vintage');
        option = null;
        var key_map = new Map();
        var app = {};
        var key_array = [];
        ras.showLoading({
            text: '正在努力的读取数据中...',
        });
        function load_rpc_async() {
            $.ajax({
                type: "post",
                async: true, //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行）
                url: "/rpc/realtime", //请求发送到TestServlet处
                data: {"type": "rpc", "sync": false},
                dataType: "json", //类型为数组
                success: function (result) {
                    var se = option.series
                    series_count = se.length
                    if (result) {
                        option.xAxis[0].data.shift();
                        option.xAxis[0].data.push(result.time.split(" ")[1]);
                        //分组
                        d = result.value
                        for (k in d) {
                            if (!key_map.has(d[k].key)) {
                                key_map.set(d[k].key, d[k].key)
                                key_array.push(d[k].key)
                            }
                        }

                        for (r in key_array) {
                            find = false;
                            for (var i = 0; i < series_count; i++) {
                                gvfa = GetValueFromArray(d,key_array[r])
                                if (se[i].name == key_array[r]) {
                                    find = true
                                    se[i].data.shift();
                                    se[i].data.push(gvfa);
                                }
                            }

                            //增加一个新的线条
                            if (!find) {
                                newob = {
                                    type: "line",
                                    name: key_array[r],
                                    data: [GetValueFromArray(d,key_array[r])]
                                }
                                se.push(newob)
                            }
                        }
                        ras.setOption(option)
                    }

                },
                error: function (errorMsg) {
                    //请求失败时执行该函数
                    alert("老数据处理失败!");

                }
            })
        }
        app.timeTicket = setInterval(function () {
            load_rpc_async()
        }, 5000 * 60);
        ;
        $.ajax({
            type: "post",
            async: true, //异步请求（同步请求将会锁住浏览器，用户其他操作必须等待请求完成才可以执行）
            url: "/rpc/historydata", //请求发送到TestServlet处
            data: {"type": "rpc", "sync": false},
            dataType: "json", //类型为数组
            success: function (result) {
                for (i in result) {
                    d = result[i].value
                    for (k in d) {
                        if (!key_map.has(d[k].key)) {
                            key_map.set(d[k].key, d[k].key)
                        }
                    }

                }
                key_map.forEach(function (item, key) {
                    key_array.push(key)
                })
                option = {
                    title: {
                        text: '上海 async'
                    },
                    legend: {
                        data: key_array
                    },
                    tooltip: {
                        trigger: 'axis'
                    },
                    toolbox: {
                        show: true,
                        feature: {
                            mark: {
                                show: true
                            },
                            dataView: {
                                show: true,
                                readOnly: false
                            },
                            magicType: {
                                show: true,
                                type: ['bar', 'stack', 'tiled']
                            },
                            restore: {
                                show: true
                            },
                            saveAsImage: {
                                show: true
                            }
                        }
                    },
                    calculable: true,
                    xAxis: [
                        {
                            data: (function () {
                                var xaxis_data = [];
                                for (i in result) {
                                    xaxis_data.unshift(result[i].time.split(" ")[1])
                                }
                                return xaxis_data;
                            })()
                        }
                    ],
                    yAxis: {},
                    series: (function () {
                        var res = [];
                        for (i in key_array) {
                            res.push({
                                type: "line",
                                name: key_array[i],
                                data: (function () {
                                    var series_data = [];
                                    for (n in result) {
                                        flag = false;
                                        for (k in result[n].value) {
                                            if (result[n].value[k].key == key_array[i]) {
                                                flag = true
                                                series_data.unshift(result[n].value[k].doc_count)
                                            }
                                        }

                                        if (!flag) {
                                            series_data.unshift(0)
                                        }
                                    }
                                    return series_data;
                                })()
                            })
                        }
                        return res
                    })()
                };
                console.log(option)
                ras.setOption(option);
                ras.hideLoading();

            },
            error: function (errorMsg) {
                //请求失败时执行该函数
                ras.showLoading()

            }
        })
    </script>

</div>

</body>
</html>